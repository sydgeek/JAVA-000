学习笔记

#### 1.使用 GCLogAnalysis.java 自己演练一遍串行/并行/CMS/G1的案例

`java -XX:+UseSerialGC -Xms512m -Xmx512m -Xloggc:gc.demo.S512.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps GCLogAnalysis`

|      | 512m |1024m |2048m |4096m |
| :--: | ---- | ---- | ---- | ---- |
|SerialGC| 9962|10625|12326|10394  |
|ParallelGC|8919|13363|14803|12994|
|ConcMarkSweepGC|10317|11521|12713|12916|
|G1GC|10595|14720|15459|15502|

- 图中展示的是在不同堆内存时使用各GC策略生成的对象个数的表格,随着堆内存增大,各GC策略回收垃圾次数均在减小;其中串行GC和并行GC在堆内存位2G时生成的对象数达到了各自不同堆内存的最高点,堆内存位512M时并行GC生成对象各数少于串行GC,分析日志看到并行GC的YoungGC频率更高且暂停时间更长,应该是每次回收的不够多,在线程抢占CPU的上下文切换耗时导致的.
- CMSGC在吞吐量表现呈现平稳上升趋势,但峰值较并行GC小了很多,分析日志看到CMSGC比并行GC的停顿时间更短,得知并行GC更注重吞吐量,CMS则更注重响应时间,可以根据不同场景来选择不同的策略.
- G1GC在吞吐上表现非常棒,且停顿时间最短,可以在不牺牲吞吐量的前提下实现短停顿的垃圾回收,由于G1垃圾收集器避免全区域垃圾收集引起的系统停顿,将堆内存划分位固定大小的区域,更合适较大的堆内存.

#### 2、使用压测工具（wrk或sb），演练gateway-server-0.0.1-SNAPSHOT.jar 示例
`java -XX:+UseSerialGC -Xmx512m -Xms512m -jar .\gateway-server-0.0.1-SNAPSHOT.jar`
`sb -u http://localhost:8088/api/hello -c 20 -N 60
模拟20个并发,请求60秒,查看RPS等信息.其它参数可通过 sb -help 查看
`
|      | 512m |1024m |2048m |4096m |
| :--: | ---- | ---- | ---- | ---- |
|SerialGC| 6615.4|6667.8|5906.3|-  |
|ParallelGC|6476.1|6544.8|6472.4|-|
|ConcMarkSweepGC|6592.6|6556|6516|6311.3|
|G1GC|6512.8|6630.4|6663.2|6630.4|
- 各种GC策略差别不大,基本没什么区别...

#### 3、不同 GC 的总结

###### 串行 GC（Serial GC）/ParNew GC
- 基于标志-复制（mark-copy）算法实现,它是一个单线程收集器,在进行垃圾收集时,必须暂停其他所有工作线程(STW),直到垃圾收集结束.
- 该种GC算法不能充分利用多核CPU,只能用单个核心收集垃圾.
- CPU利用率高,暂停时间长,对于单CPU运行环境来说,没有线程交互开销,可以获得最高的单线程垃圾收集效率.
- ParNew是Serial GC的变种,可以利用多核心收集垃圾.
###### 并行 GC（Parallel GC）

- 年轻代和老年代的垃圾回收都会触发 STW 事件.(暂停工作线程,默认利用所有CPU核心进行垃圾收集,可通过-XX：ParallelGCThreads=N 来指定 GC 线程数)
- 在年轻代(Parallel Scanvenge)使用 标记-复制（mark-copy）算法，在老年代(Parallel Old)使用 标记-清除-整理（mark-sweepcompact）算法
- 吞吐量较CMS更大,但停顿时间更长.
###### CMS GC（Mostly Concurrent Mark and Sweep Garbage Collector）
- ###### 6各阶段: 
- 
  1.  Initial Mark(初始标记): 该阶段伴随着 STW 暂停.初始标记的目标是标记所有的根对象,包括根对象直接引用的对象,以及被年轻代中所有存活对象所引用的对象(老年代单独回收).
  2. Concurrent Mark(并发标记): 该阶段,CMS GC遍历老年代,标记所有的存活对象,从前一阶段 “Initial Mark” 找到的根对象开始算起. “并发标记”阶段,就是与应用程序同时运行,不用暂停的阶段.
  3. Concurrent Preclean(并发发预清理): 此阶段同样是与应用线程并发执行的，不需要停止应用线
     程,如果在并发标记过程中引用关系发生了变化，JVM 会通过“Card(卡片)”的方式将发生了改变的区域标记为“脏”区，这就是所谓的 卡片标记(Card Marking).
  4. Final Remark(最终标记): 最终标记阶段是此次 GC 事件中的第二次(也是最后一次)STW 停顿.本阶段的目标是完成老年代中所有存活对象的标记. 因为之前的预清理阶段是并发执行的,有可能 GC 线程跟不上应用程序的修改速度。所以需要一次STW 暂停来处理各种复杂的情况.通常 CMS 会尝试在年轻代尽可能空的情况下执行 Final Remark 阶段,以免连续触发多次 STW 事件.
  5. Concurrent Sweep(并发清除): 此阶段与应用程序并发执行,不需要 STW 停顿.JVM 在此阶段删除不再使用的对象,并回收他们占用的内存空间.
  6. Concurrent Reset(并发重置): 此阶段与应用程序并发执行，重置 CMS 算法相关的内部数据,为下一次 GC 循环做准备.

- CMS 垃圾收集器在<u>**减少停顿**</u>时间上做了很多复杂而有用的工作,用于垃圾回收的并发线程执行的同时,并不需要暂停应用线程. 当然,CMS 也有一些缺点,其中**最大的问题就是老年代内存碎片问题**(因为不压缩),**在某些情况下 GC 会造成不可预测的暂停时间,特别是堆内存较大的情况下**.
- 与Parallel GC相比,CMS稳定性更好,以牺牲吞吐量来换取更少的停顿.

###### G1 GC
- G1垃圾收集器为了避免全区域垃圾收集引起的停顿,将堆内存划分为大小固定的一些区块(smart heap regions 通常是2048个).堆不再分成分成年轻代和老年代,区块根据使用来定义属于哪一代.在逻辑上,所有的Eden区和Survivor区合起来就是年轻代,所有的Old区拼在一起那就是老年代.
- G1 GC最主要的设计目标是:将STW停顿的时间和分布,变成可预期且可配置的.
- 根据区块来独立使用并跟踪垃圾收集进度,同时维护了一个优先级列表,根据系统允许的最长垃圾收集时间,优先回收垃圾最多的区域.
- 默认最大停顿时间位200ms, 可通过 -XX:MaxGCPauseMillis 调整.一般没人用默认,建议设置位50.
- 策略实现复杂,可精确控制停顿时间,适合内存大的堆.